# DSA? (crypto)

## 問題設定
RSAベースの電子署名の実装が与えられるのでフラグを抽出したい

## 解法
プログラムを整理すると以下の関係が分かる
```
p,q ~ 1024bit
h ~ 256bit
m ~ 232bit
x ~ 384bit

y = g^x mod p
k = m^-1 mod q
r = (g^k mod p) mod q
s = k^-1 * (h + xr) mod q

m, x, k: (unknown)
```

最後の式を変形すると
`s = mh + mxr + qt` (`t`は実数)となり、`mh`と`mx`のbit数が短いことからLLLで解けそうという気持ちになるが、色々試したもののフラグが取れなかった

プログラムを冷静に読むと`x`は実行のたびにランダムに生成され、複数の`s`を取得できることに気づくので、以下のように変形できる

`r^-1 * (s_i - s_j) = m * x_i (mod q)`

ここで、`m * x_i < q`であり、`m * x_i`は複数個用意できるので、それらの`gcd`を取ることで`m`を抽出できる

## exploit
わざわざ通信するスクリプトを書くのも面倒だったので`s`は手動で持ってきた
```python
from sage.all import *
from Crypto.Util.number import long_to_bytes, bytes_to_long, inverse

p = 279190269876274251324426322312362714733335466785172094935419915241950478848265797905794448859598516635356219340992681163129868259377870067135628444717941906265805473582625356077252298182649372163332524356633146053976125545725650767983804894392935339017757208219447046253242656931615084883658404097001099730007
q = 139595134938137125662213161156181357366667733392586047467709957620975239424132898952897224429799258317678109670496340581564934129688935033567814222358970953132902736791312678038626149091324686081666262178316573026988062772862825383991902447196467669508878604109723523126621328465807542441829202048500549865003
g = 2
y = 188990551796264980846507345762316584368593264442463352024025631888234954152129612048105124498784956659090673449935115285880618416772735864356737110260666117868910931397243039247921055813704086870702494757050150964327947252872331462638659320415877468634957430101124432089697306725144081571450719634755741719616
r = 61401707010758101526146375076142785590307812475121812316952376486069149360425245868500855973757366554075933599220935059105890347272857469593141580674416812501978293803766670329096383435341545996560650936693344739955943829806575705777357363320849419106573553984283202966428145927420324135463723534658578592614
s1 = 112688559225701536235639570951051165619403043958535880339574039202594629922556077516583691074075452217374435623617068599621354175935939164228440880951874914647055689281309486952812418949727727996018163813552050184189199445250714357330541986775060512697655926297939407439921581154809748730103873517166403073695
s2 = 56399020207910808518528616149932720836049845483639912788847837325515758994917334388568747284185801024570994668795397168408433426037197034396746134891415743432592828220898582827912177228791909900704989501136912452394023407189166592976186449057540404716155244755798943460412161717336718281217070786608765607068
s3 = 5867235359446576214461897592924258491033987424448791611268665131640478202172090418649546206851475844688842905203341549237665306374641550032005640127982264241972368073407141602946063816609904948125632871439222575182168502714819108049620138628668903706007039746231487253918759203467196734190452084143914953987
s4 = 125717177853283680465994188592418652202515028807690001230163698770290935437003271113704861789622688989159249992684734321758613367167887803197335994214918986936687429716237249528909200402573931389322296596386353739789398815606333578179553158590690881411572970952766794530939178504579709035227105331160048413065
h = int("7aad5b407493e83e9c8a11170733019dfb55dcdb0b7ec677ded13ad9ab16cc82", 16)

mx1 = inverse(r, q) * (s2 - s1) % q
mx2 = inverse(r, q) * (s3 - s2) % q
mx3 = inverse(r, q) * (s4 - s3) % q

mx1 = min(mx1, q-mx1)
mx2 = min(mx2, q-mx2)
mx3 = min(mx3, q-mx3)
print(long_to_bytes(gcd(gcd(mx1, mx2), mx3)))

```
